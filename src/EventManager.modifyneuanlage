/**
 * Project IT Calendar - Event Manager Component
 * --------------------------------------------
 * Handles synchronization with the system calendar server (Cinnamon.CalendarServer)
 * and provides ICS file import capabilities.
 * * * ARCHITECTURAL DESIGN:
 * 1. HYBRID MODULE SYSTEM:
 * Uses 'export' for IDE/AMD support and 'global' assignment for monolithic 
 * bundling. This ensures compatibility with both 'module: None' and 'module: AMD'.
 * * 2. GJS SIGNALS INTEGRATION:
 * Uses 'imports.signals' to add event-emitter capabilities. This allows the 
 * View to react to 'events-updated' signals without tight coupling.
 * * 3. ASYNCHRONOUS DBUS COMMUNICATION:
 * Communicates with 'org.cinnamon.CalendarServer' via DBus. All calls are 
 * handled asynchronously to keep the UI responsive.
 * * 4. MODERN GJS STANDARDS:
 * Uses TextDecoder or .toString() for data conversion instead of legacy 
 * byte-array wrappers where possible.
 * * * * ARCHITECTURE OVERVIEW:
 * 1. EventManager: Handles data fetching (ICS/Evolution/System).
 * 2. CalendarLogic: Pure JS logic for date calculations and holiday parsing.
 * 3. CalendarView: The complex St.Table based UI grid.
 * 4. EventListView: Specialized view for displaying event details.
 * * * SYSTEM INTEGRATION:
 * - Uses 'Settings' for user-defined date formats and behavior.
 * - Uses 'AppletPopupMenu' to host the calendar UI.
 * - Uses 'KeybindingManager' for global hotkey support.
 * * @author Arnold Schiller <calendar@projektit.de>
 * @link https://github.com/ArnoldSchiller/calendar
 * @link https://projektit.de/kalender
 * @license GPL-3.0-or-later
 */

// GJS Imports - Accessing native system APIs
const Gio = imports.gi.Gio;
const Cinnamon = imports.gi.Cinnamon;
const GLib = imports.gi.GLib;
const Signals = imports.signals;
const Mainloop = imports.mainloop;
const ECal = imports.gi.ECal;
const ICal = imports.gi.ICalGLib;
const EDataServer = imports.gi.EDataServer;

/**
 * EventData Interface
 * Defines the internal representation of a calendar event.
 */
export interface EventData {
    id: string;
    sourceUid: string;
    start: Date;        
    end: Date;          // bei Ganztag = Folgetag 00:00)
    summary: string;
    description?: string;
    color: string;
    isFullDay: boolean;
}

/**
 * DateRange Interface
 * Defines a date range with start and end dates.
 */
export interface DateRange {
    from: Date;
    to: Date;
}

/**
 * EventManager Interface for Signals
 * This allows TypeScript to recognize the .connect() and .emit() methods 
 * added via Signals.addSignalMethods.
 */
export interface EventManager extends Signals.Signals {}

export class EventManager {
    private _server: any = null;
    private _events: EventData[] = [];
    private _isReady: boolean = false;
    private _selectedDate: Date;
    private _uuid: string;
    
    private _registry: any | null = null;
    private _clientCache = new Map<string, any>();

    /**
     * @param uuid - The unique identifier of the applet for logging purposes.
     */
    constructor(uuid: string = "EventManager@default") {
        this._uuid = uuid;
        this._selectedDate = new Date();
        this._loadInitialData();
        this._initProxy();

        // Refresh loop: Synchronize with system calendar every 60 seconds
        Mainloop.timeout_add_seconds(60, () => {
            this.refresh();
            return true; // Keep the timer running
        });
    }

    /**
     * Loads placeholder data during startup to ensure the UI is never empty.
     */
    private _loadInitialData(): void {
        const today = new Date();
        this._events = [
            {
                id: "init-state",
                sourceUid: "Teststring",
                start: today,
                end: today,
                summary: "Calendar Manager Active",
                description: "Synchronizing with system calendar...",
                color: "#3498db",
                isFullDay: false
            }
        ];
    }

    /**
     * Initializes the DBus Proxy for Cinnamon's Calendar Server.
     * This is the bridge to GNOME Evolution / Google Calendar / Local calendars.
     */
    private _initProxy(): void {
        Cinnamon.CalendarServerProxy.new_for_bus(
            Gio.BusType.SESSION,
            Gio.DBusProxyFlags.NONE,
            "org.cinnamon.CalendarServer",
            "/org/cinnamon/CalendarServer",
            null,
            (obj, res) => {
                try {
                    this._server = Cinnamon.CalendarServerProxy.new_for_bus_finish(res);
                    
                    // Listen for server-side updates (e.g., user adds event in Evolution)
                    this._server.connect('events-added-or-updated', this._onEventsChanged.bind(this));
                    this._server.connect('events-removed', this._onEventsChanged.bind(this));
                    
                    this._isReady = true;
                    this.emit('manager-ready');
                    
                    // Initial fetch for the current month view
                    this.refresh();
                } catch (e) {
                    if (typeof global !== 'undefined') {
                        global.logError(`${this._uuid}: DBus Connection Error: ${e}`);
                    }
                }
            }
        );
    }

    public selectDate(date: Date): void {
        this._selectedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }

    public getEventsForSelectedDate(): EventData[] {
        return this.getEventsForDate(this._selectedDate);
    }

    public hasEvents(date: Date): boolean {
        return this.getEventsForDate(date).length > 0;
    }

    /**
     * Fetches events for a specific Unix timestamp range from the server.
     */
    public fetchRange(start: Date, end: Date): void {
        if (!this._server) return;
        let startUnix = Math.floor(start.getTime() / 1000);
        let endUnix = Math.floor(end.getTime() / 1000);

        // Tell the server which time window we are interested in
        this._server.call_set_time_range(startUnix, endUnix, true, null, (server, res) => {
            try { 
                this._server.call_set_time_range_finish(res); 
            } catch (e) {
                // Ignore finish errors if the applet is closing
            }
        });
    }

    public getEventsForRange(range: DateRange): EventData[] {
        const from = range.from.getTime();
        const to   = range.to.getTime();

        return this._events
            .filter(ev => {
                    const start = ev.start.getTime();
                    const end   = ev.end.getTime();
                    return end >= from && start <= to;
            })
            .sort((a, b) => a.start.getTime() - b.start.getTime());
    }

    /**
     * Filters cached events by a specific calendar day.
     */
    public getEventsForDate(date: Date): EventData[] {
        const from = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        const to   = new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
        return this.getEventsForRange({ from, to });
    }

    public getEventsForMonth(year: number, month: number): EventData[] {
        const from = new Date(year, month, 1);
        const to   = new Date(year, month + 1, 0, 23, 59, 59);
        return this.getEventsForRange({ from, to });
    }

    public getEventsForYear(year: number): EventData[] {
        const from = new Date(year, 0, 1);
        const to   = new Date(year, 11, 31, 23, 59, 59);
        return this.getEventsForRange({ from, to });
    }

    /**
     * Refreshes the event cache by requesting data for a 9-month window.
     */
    public refresh(): void {
        if (!this._server) return;
        const now = new Date();
        const start = new Date(now.getFullYear(), now.getMonth() - 2, 1);
        const end = new Date(now.getFullYear(), now.getMonth() + 7, 0);
        this.fetchRange(start, end);
    }

    /**
     * Callback triggered by DBus when the calendar server emits new data.
     */
    private _onEventsChanged(server: any, varray: any): void {
        const rawEvents = varray.unpack();
        this._events = rawEvents.map((e: any) => {
            const [fullId, color, summary, allDay, start, end] = e.deep_unpack();
            
            let sourceUid = "";
            let eventId = fullId;
            
            if (fullId.includes(':')) {
                const parts = fullId.split(':');
                sourceUid = parts[0];
                eventId = parts.slice(1).join(':');
            }

            return {
                id: eventId,
                sourceUid: sourceUid,
                summary: summary,
                color: color,
                start: new Date(start * 1000),
                end: new Date(end * 1000),
                isFullDay: allDay
            };
        });
        this.emit('events-updated');
    }

    /**
     * ICS IMPORT LOGIC
     * Parses a local .ics file and pushes events to the system calendar via DBus.
     */
    public async importICSFile(icsPath: string, color: string = "#ff6b6b"): Promise<void> {
        if (!this._server) {
            global.logError(this._uuid + ": CalendarServer not ready for ICS-Import");
            return;
        }

        try {
            const file = Gio.File.new_for_path(icsPath);
            const [ok, contents] = await new Promise<[boolean, Uint8Array]>(resolve => {
                file.load_contents_async(null, (f, res) => {
                    try {
                        const [success, data] = f!.load_contents_finish(res);
                        resolve([success, data]);
                    } catch (e) {
                        resolve([false, new Uint8Array()]);
                    }
                });
            });

            if (!ok) throw new Error("Can't read ICS file.");
            const icsText = contents.toString(); 

            const veventMatches = icsText.match(/BEGIN:VEVENT[\s\S]*?END:VEVENT/g);
            if (!veventMatches) return;

            let importedCount = 0;
            for (const veventBlock of veventMatches) {
                try {
                    const summary = (veventBlock.match(/SUMMARY:(.*)/i)?.[1] || 'Unnamed').trim();
                    const description = (veventBlock.match(/DESCRIPTION:(.*)/i)?.[1] || '').trim();
                    const dtstartMatch = veventBlock.match(/DTSTART(?:;VALUE=DATE)?[:;]([^:\n\r]+)/i);
                    const dtendMatch = veventBlock.match(/DTEND(?:;VALUE=DATE)?[:;]([^:\n\r]+)/i);
            
                    if (!dtstartMatch) continue;
            
                    const startStr = dtstartMatch[1].trim();
                    const endStr = dtendMatch ? dtendMatch[1].trim() : startStr;

                    const start = this._parseICSDate(startStr);
                    const end = this._parseICSDate(endStr);
                    const allDay = startStr.length === 8; 
            
                    const eventToImport: EventData = {
                        id: "", 
                        sourceUid: "", 
                        summary: summary,
                        description: description,
                        start: start,
                        end: end,
                        isFullDay: allDay,
                        color: "#3498db"
                    };
            
                    this.addEvent(eventToImport);
                    importedCount++;
                } catch (e) {
                    global.logError(this._uuid + ": VEVENT parsing error: " + e);
                }
            }
            global.log(this._uuid + `: ${importedCount} Events imported from ${icsPath}`);
        } catch (e) {
            global.logError(this._uuid + `: ICS Import Error ${icsPath}: ${e}`);
        }
    }

    private _parseICSDate(icsDate: string): Date {
        if (icsDate.length === 8) {
            return new Date(
                parseInt(icsDate.substr(0,4)),
                parseInt(icsDate.substr(4,2))-1,
                parseInt(icsDate.substr(6,2))
            );
        }
        return new Date(icsDate.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z?)/, '$1-$2-$3T$4:$5:$6$7'));
    }

    /**
     * Adds an event to the system calendar using the sourceUid mapping.
     * * RATIONALE: 
     * Since the Cinnamon Calendar Server provides IDs in "source:id" format,
     * we use the extracted sourceUid to target the specific EDS calendar.
     * Adds an event directly to the Evolution Data Server (EDS).
     * The standard 'Cinnamon.CalendarServer' is read-only via DBus. To allow 
     * adding events without modifying system-files or requiring external tools, 
     * we interface directly with 'libecal' and 'libedataserver' (EDS). 
     * This ensures the event is synced with Evolution, Google Calendar, etc.
     */
     /**
     * Event-Daten auf ICal-Komponente mappen
     * Zentralisiert das Setzen von Summary, Description und Zeiten.
     */
    private _applyEventToComponent(icalComp: any, ev: EventData): void {
        icalComp.set_summary(ev.summary);
        icalComp.set_description(ev.description || "");

        const tz = ICal.Timezone.get_utc_timezone();
        
        // START-ZEIT
        let start = ICal.Time.new_null_time();
        if (ev.isFullDay) {
            start.set_date(ev.start.getFullYear(), ev.start.getMonth() + 1, ev.start.getDate());
            start.set_is_date(true);
        } else {
            start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
        }

        // END-ZEIT
        let end = ICal.Time.new_null_time();
        if (ev.isFullDay) {
            // WICHTIG: Wir nehmen das bestehende Enddatum.
            // Falls Start und Ende gleich sind (1-Tages-Termin), muss das iCal-Ende +1 Tag sein.
            // Falls es bereits ein Mehrtages-Termin ist, mÃ¼ssen wir sicherstellen, 
            // dass das iCal-Ende mindestens einen Tag NACH dem Start liegt.
            
            let endDate = new Date(ev.end);
            
            // Wenn das Ende zeitlich gleich oder vor dem Start liegt (Sicherheitscheck), 
            // machen wir einen 1-Tages-Termin daraus.
            if (endDate.getTime() <= ev.start.getTime()) {
                endDate.setDate(ev.start.getDate() + 1);
            }
            
            // iCal Ganztag Standard: Das Datum im Feld DTEND wird nicht mehr zum Termin gezÃ¤hlt.
            end.set_date(endDate.getFullYear(), endDate.getMonth() + 1, endDate.getDate());
            end.set_is_date(true);
        } else {
            end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
        }

        icalComp.set_dtstart(start);
        icalComp.set_dtend(end);
    }


    /**
     * Hauptmethode zum HinzufÃ¼gen oder Aktualisieren
     */
    public addEvent(ev: EventData): void {
    	if (ev.id && ev.sourceUid) {
        	this._modifyExistingEvent(ev);
    	} else {
        
        	this._createNewEvent(ev);
    	}
	
     }
    
    private _createNewEvent(ev: EventData): void {
    	const source = this._getDefaultWritableSource();
    	if (!source) {
        	global.logError("Create: Keine schreibbare Kalenderquelle");
        	return;
    	}

	// Erzeuge eine saubere VEVENT Komponente
	// Wir nutzen ICal (ICalGLib), um das GrundgerÃ¼st stabil zu bauen
         let icalComp = ECal.Component.new();
    	 icalComp.set_new_vtype(ECal.ComponentVType.EVENT);
    
    	//  DIE UID SETZEN - EDS verweigert sonst den Dienst
    	// Wenn ev.id leer ist, erzeuge hier eine
    	const finalId = ev.id || GLib.uuid_string_random();
    	icalComp.set_uid(finalId);
    
    	ECal.Client.connect(source, ECal.ClientSourceType.EVENTS, 30, null, (_obj, res) => {
        try {
            const client = ECal.Client.connect_finish(res);
            // Wir Ã¼bergeben das vorbereitete icalComp
            this._createAsNew(client, ev, icalComp);
        } catch (e) {
            global.logError("Connect failed: " + e);
        }
      });
    }
	
    private _modifyExistingEvent(ev: EventData): void {
        const source = this._resolveSource(ev.sourceUid);
        if (!source) return;

        ECal.Client.connect(source, ECal.ClientSourceType.EVENTS, 30, null, (_obj, res) => {
            try {
                const client = ECal.Client.connect_finish(res);

                if (ev.id && ev.id !== "" && !ev.id.startsWith("ics_")) {
                    // --- SMART MERGE (Vergleichs-Logik) ---
                    // FIX: 4 Argumente, damit der Aufruf nicht fehlschlÃ¤gt
                    client.get_object(ev.id, null, null, (_obj2: any, getRes: any) => {
                        try {
                            const result = client.get_object_finish(getRes);
                            const icalComp = Array.isArray(result) ? result[1] : result;

				if (icalComp) {
				    let anyChange = false;


				    // --- 1. SUMMARY ---
				    const oldSummary = icalComp.get_summary() || "";
				    // Nur Ã¤ndern, wenn UI-Wert vorhanden UND anders als im Kalender
				    if (ev.summary && ev.summary.trim() !== "" && ev.summary !== oldSummary) {
				        icalComp.set_summary(ev.summary);
				        anyChange = true;
				        global.log(`${this._uuid}: Update Summary`);
				    }

				    // --- 2. DESCRIPTION ---
				    const oldDesc = icalComp.get_description() || "";
				    // Schutz: Nur Ã¤ndern, wenn im Formular tatsÃ¤chlich Text steht und dieser abweicht
				    if (ev.description && ev.description.trim() !== "" && ev.description !== oldDesc) {
				        icalComp.set_description(ev.description);
				        anyChange = true;
				        global.log(`${this._uuid}: Update Description`);
				    }
				
			    // --- 3. ZEITEN (Der kritische Teil fÃ¼r Mehrtages-Events) ---
				try {
				    const oldStartComp = icalComp.get_dtstart();
				    const oldEndComp = icalComp.get_dtend();
					    
				    if (oldStartComp && oldEndComp) {
    			          const oldStartTimeObj = (typeof oldStartComp.get_value === 'function') ? oldStartComp.get_value() : oldStartComp;
			                const oldEndTimeObj = (typeof oldEndComp.get_value === 'function') ? oldEndComp.get_value() : oldEndComp;
        
					        const newStartSeconds = Math.floor(ev.start.getTime() / 1000);
        
					        if (oldStartTimeObj.as_timet() !== newStartSeconds) {
					            // Die Startzeit hat sich geÃ¤ndert!
					            // Berechnung der ursprÃ¼nglichen Dauer, um sie zu erhalten:
					            const durationSeconds = oldEndTimeObj.as_timet() - oldStartTimeObj.as_timet();
            
					            // Neues Start-Objekt bauen
					            const tz = ICal.Timezone.get_utc_timezone();
					            let newStart = ICal.Time.new_from_timet_with_zone(newStartSeconds, 0, tz);
					            if (ev.isFullDay) newStart.set_is_date(true);
            
					            // Neues Ende-Objekt basierend auf der ALTEN Dauer berechnen
					            let newEnd = ICal.Time.new_from_timet_with_zone(newStartSeconds + durationSeconds, 0, tz);
					            if (ev.isFullDay) newEnd.set_is_date(true);

					            icalComp.set_dtstart(newStart);
					            icalComp.set_dtend(newEnd);
            
					            anyChange = true;
					            global.log(`${this._uuid}: Update Times (Dauer von ${durationSeconds/3600}h erhalten)`);
					        }
					    }
					} catch (e) {
					    global.logWarning(`${this._uuid}: Zeit-Merge fehlgeschlagen: ${e}`);
					}

				    // --- FINALE ---
				    if (anyChange) {
				        client.modify_object(icalComp, ECal.ObjModType.THIS, 0, null, (_c: any, mRes: any) => {
				            try {
				                client.modify_object_finish(mRes);
				                global.log(`${this._uuid}: Smart Merge erfolgreich durchgefÃ¼hrt.`);
				                this.refresh();
				            } catch (err) { global.logError("Modify finish failed: " + err); }
				        });
				    } else {
				        global.log(`${this._uuid}: Keine Ã„nderungen notwendig - Master-Daten bleiben unberÃ¼hrt.`);
				    }
				}
                        } catch (e) {
                            // Nur wenn get_object wirklich sagt "UID existiert nicht"
                            global.logWarning(`${this._uuid}: Smart Merge fehlgeschlagen (ID nicht gefunden): ${e}`);
                            this._createAsNew(client, ev);
                        }
                    });
                } else {
                    this._createAsNew(client, ev);
                }
            } catch (e) {
                global.logError("Connection failed: " + e);
            }
        });
    }

    private _applyTimesToComponent(icalComp: any, ev: EventData): void {
        const tz = ICal.Timezone.get_utc_timezone();
        let start = ICal.Time.new_null_time();
        let end = ICal.Time.new_null_time();

        if (ev.isFullDay) {
            start.set_date(ev.start.getFullYear(), ev.start.getMonth() + 1, ev.start.getDate());
            start.set_is_date(true);
            let endDate = new Date(ev.end);
            if (endDate.getTime() <= ev.start.getTime()) endDate.setDate(ev.start.getDate() + 1);
            end.set_date(endDate.getFullYear(), endDate.getMonth() + 1, endDate.getDate());
            end.set_is_date(true);
        } else {
            start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
            end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
        }
        icalComp.set_dtstart(start);
        icalComp.set_dtend(end);
    }
    /**
     * Erstellt ein komplett neues Objekt im EDS.
     * Fix: Erfordert in dieser GJS-Umgebung 4 Argumente (comp, opid, cancellable, callback).
     */
    private _createAsNew(client: any, ev: EventData): void {
        try {
            const icalComp = ICal.Component.new(ICal.ComponentKind.VEVENT_COMPONENT);
            
            // Bei Neuanlage fÃ¼llen wir alles initial
            icalComp.set_summary(ev.summary || "New Event");
            icalComp.set_description(ev.description || "");
            
            // Zeit-Mapping fÃ¼r Neuanlage
            this._applyTimesToComponent(icalComp, ev);
            
            // FIX: 4 Argumente (Component, opid/null, Cancellable/null, Callback)
            client.create_object(icalComp, null, null, (_c: any, res: any) => {
                try {
                    const result = client.create_object_finish(res);
                    // GJS gibt oft [success, newUid] zurÃ¼ck
                    const success = Array.isArray(result) ? result[0] : result;
                    
                    if (success) {
                        global.log(`${this._uuid}: Event erfolgreich erstellt.`);
                        this.refresh();
                    }
                } catch (e) {
                    global.logError(`${this._uuid}: create_object_finish failed: ${e}`);
                }
            });
        } catch (e) {
            global.logError(`${this._uuid}: _createAsNew failed: ${e}`);
        }
    }
     /**
     * Findet eine schreibbare Kalenderquelle.
     */
    private _resolveSource(sUid?: string): any {
        if (!this._registry) {
            this._registry = EDataServer.SourceRegistry.new_sync(null);
        }

        if (sUid) {
            try { 
                let s = this._registry.ref_source(sUid); 
                if (s) return s;
            } catch (e) {}
        }

        const sources = this._registry.list_sources(EDataServer.SOURCE_EXTENSION_CALENDAR);
        
        // 1. Suche nach bevorzugten Namen (System/Personal/Local)
        let bestSource = sources.find((s: any) => {
            try {
                const ext = s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR);
                // Sicherer Check auf Readonly
                const ro = (typeof ext.get_readonly === 'function') ? ext.get_readonly() : ext.readonly;
                if (ro === true) return false;

                const name = s.get_display_name().toLowerCase();
                return name.includes("system") || name.includes("personal") || name.includes("local");
            } catch(e) { return false; }
        });

        if (bestSource) return bestSource;

        // 2. Fallback: Nimm IRGENDEINEN der nicht readonly ist
        return sources.find((s: any) => {
            try {
                const ext = s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR);
                const ro = (typeof ext.get_readonly === 'function') ? ext.get_readonly() : ext.readonly;
                return ro !== true;
            } catch(e) { return false; }
        });
    }
    /* 
     * von Terminen des Proxy dÃ¼rfen wir nur modify machen
     * also mÃ¼ssen wir fÃ¼r create new noch die writable finden
     */
    private _getDefaultWritableSource(): any {
      if (!this._registry) {
        this._registry = EDataServer.SourceRegistry.new_sync(null);
      }

      const sources = this._registry.list_sources(EDataServer.SOURCE_EXTENSION_CALENDAR);

      return sources.find((s: any) => {
         try {
            const ext = s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR);
            if (ext.get_readonly && ext.get_readonly()) return false;

            // ðŸ”‘ DAS ist wichtig
            return s.get_parent() !== null;
         } catch {
            return false;
         }
      });
    }


    /**
     * Date zu ICal.Time
     * Regelt Monats-Offset (+1) und Ganztags-Flags.
     */
    private _dateToICalTime(date: Date, isFullDay: boolean): any {
        const tz = ICal.Timezone.get_utc_timezone();
        const time = ICal.Time.new_full(
            date.getFullYear(),
            date.getMonth() + 1,
            date.getDate(),
            isFullDay ? 0 : date.getHours(),
            isFullDay ? 0 : date.getMinutes(),
            0,
            tz
        );
        if (isFullDay) time.set_is_date(true);
        return time;
    }

}

/**
 * GJS SIGNAL MIXIN
 * This injects the Signal emitter methods into the EventManager prototype.
 * Essential for the 'events-updated' notification system.
 */
Signals.addSignalMethods(EventManager.prototype);

/**
 * HYBRID EXPORT
 */
if (typeof exports !== 'undefined') {
    exports.EventManager = EventManager;
}
(global as any).EventManager = EventManager;
