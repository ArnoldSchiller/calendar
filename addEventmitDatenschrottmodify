public addEvent(ev: EventData): void {
        try {
            if (!this._registry) {
                this._registry = EDataServer.SourceRegistry.new_sync(null);
            }

            let source = null;

            // 1. Bestehende Quelle finden
            const sUid = ev.sourceUid;
            if (typeof sUid === 'string' && sUid !== "") {
                try {
                    source = this._registry.ref_source(sUid);
                } catch (e) {
                    global.logError(`${this._uuid}: Could not ref_source for UID: ${sUid}`);
                }
            }

            // 2. Fallback für neue Events (Systemkalender suchen)
            if (!source) {
                const sources = this._registry.list_sources(EDataServer.SOURCE_EXTENSION_CALENDAR);
                
                source = sources.find((s: any) => {
                    // Sicherer Check auf Schreibbarkeit ohne Funktionsaufruf
                    let isWritable = false;
                    try {
                        // Wir versuchen die Extension für den Kalender zu holen, 
                        // dort liegt oft das korrekte readonly-Flag
                        let extension = s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR);
                        isWritable = !extension.get_readonly();
                    } catch (e) {
                        // Zweiter Versuch direkt über das Source-Objekt
                        isWritable = (typeof s.get_readonly === 'function') ? !s.get_readonly() : true;
                    }
                    
                    const name = s.get_display_name().toLowerCase();
                    return isWritable && (name.includes("system") || name.includes("personal") || name.includes("local"));
                });

                if (!source) {
                    source = sources.find((s: any) => {
                        try {
                            return !s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR).get_readonly();
                        } catch(e) { return true; }
                    });
                }
            }

            if (!source) {
                global.logError(`${this._uuid}: No source found to save the event.`);
                return;
            }

            ECal.Client.connect(source, ECal.ClientSourceType.EVENTS, 30, null, (_obj, res) => {
                try {
                    const client = ECal.Client.connect_finish(res);
                    const icalComp = ICal.Component.new(ICal.ComponentKind.VEVENT_COMPONENT);

                    if (ev.id) {
                        icalComp.set_uid(ev.id);
                    }

                    icalComp.set_summary(ev.summary);
                    if (ev.description) icalComp.set_description(ev.description);

                    const tz = ICal.Timezone.get_utc_timezone();
                    let start: any, end: any;

                    if (ev.isFullDay) {
                        start = ICal.Time.new_null_time();
                        start.set_date(ev.start.getDate(), ev.start.getMonth() + 1, ev.start.getFullYear());
                        start.set_is_date(true);

                        end = ICal.Time.new_null_time();
                        end.set_date(ev.end.getDate(), ev.end.getMonth() + 1, ev.end.getFullYear());
                        end.set_is_date(true);
                    } else {
                        start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
                        end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
                    }

                    icalComp.set_dtstart(start);
                    icalComp.set_dtend(end);

                    // --- HIER FEHLTE DIE SPEICHER-LOGIK ---

                    if (ev.id && ev.id !== "" && !ev.id.startsWith("ics_")) {
                        // Bestehendes Event updaten (5 Argumente wie gefordert)
                        client.modify_object(icalComp, ECal.ObjModType.THIS, 0, null, (_c: any, modifyRes: any) => {
                            try {
                                client.modify_object_finish(modifyRes);
                                global.log(`${this._uuid}: Event updated successfully.`);
                            } catch (e) {
                                global.logError(`${this._uuid}: modify_object_finish failed: ${e}`);
                            }
                        });
                    } else {
                        // Neues Event erstellen (4 Argumente)
                        client.create_object(icalComp, null, (_c: any, createRes: any) => {
                            try {
                                const [success, newUid] = client.create_object_finish(createRes);
                                if (success) {
                                    global.log(`${this._uuid}: New event created. UID: ${newUid}`);
                                }
                            } catch (e) {
                                global.logError(`${this._uuid}: create_object_finish failed: ${e}`);
                            }
                        });
                    }

                } catch (e) {
                    global.logError(`${this._uuid}: Calendar client connection failed: ${e}`);
                }
            });

        } catch (e) {
            global.logError(`${this._uuid}: Fatal error in addEvent: ${e}`);
        }
    }
