public addEvent(ev: EventData): void {
    const source = this._resolveSource(ev.sourceUid);
    if (!source) return;

    ECal.Client.connect(source, ECal.ClientSourceType.EVENTS, 30, null, (_obj, res) => {
        try {
            const client = ECal.Client.connect_finish(res);

            if (ev.id && ev.id !== "" && !ev.id.startsWith("ics_")) {
                // --- FALL A: SMART MERGE (Update) ---
                client.get_object(ev.id, null, (_obj2, getRes) => {
                    try {
                        const [success, icalComp] = client.get_object_finish(getRes);
                        if (success && icalComp) {
                            this._fillComponent(icalComp, ev); // Bestehendes Objekt anpassen
                            client.modify_object(icalComp, ECal.ObjModType.THIS, 0, null, (_c, modRes) => {
                                try { client.modify_object_finish(modRes); this.refresh(); } 
                                catch (e) { global.logError("Modify failed: " + e); }
                            });
                        }
                    } catch (e) { global.logError("Fetch object failed: " + e); }
                });
            } else {
                // --- FALL B: NEUANLAGE ---
                const icalComp = ICal.Component.new(ICal.ComponentKind.VEVENT_COMPONENT);
                this._fillComponent(icalComp, ev); // Neues Objekt befüllen
                client.create_object(icalComp, null, (_c, createRes) => {
                    try { client.create_object_finish(createRes); this.refresh(); } 
                    catch (e) { global.logError("Create failed: " + e); }
                });
            }
        } catch (e) {
            global.logError(`${this._uuid}: Client Error: ${e}`);
        }
    });
}

/**
 * Zentrales Mapping: Verhindert Code-Dopplung
 */
private _fillComponent(icalComp: any, ev: EventData): void {
    icalComp.set_summary(ev.summary);
    if (ev.description) icalComp.set_description(ev.description);

    const tz = ICal.Timezone.get_utc_timezone();
    let start: any, end: any;

    if (ev.isFullDay) {
        // Die robuste Methode, die bei dir klappte
        start = ICal.Time.new_null_time();
        start.set_date(ev.start.getDate(), ev.start.getMonth() + 1, ev.start.getFullYear());
        start.set_is_date(true);

        end = ICal.Time.new_null_time();
        end.set_date(ev.end.getDate(), ev.end.getMonth() + 1, ev.end.getFullYear());
        end.set_is_date(true);

        // Der Fix für Ein-Tages-Termine (Start = Ende)
        if (ev.start.toDateString() === ev.end.toDateString()) {
            end.adjust(1, 0, 0, 0); 
        }
    } else {
        start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
        end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
    }

    icalComp.set_dtstart(start);
    icalComp.set_dtend(end);
}
