public addEvent(ev: EventData): void {
        try {
            if (!this._registry) {
                this._registry = EDataServer.SourceRegistry.new_sync(null);
            }

            let source = null;

            // 1. Bestehende Quelle finden
            const sUid = ev.sourceUid;
            if (typeof sUid === 'string' && sUid !== "") {
                try {
                    source = this._registry.ref_source(sUid);
                } catch (e) {
                    global.logError(`${this._uuid}: Could not ref_source for UID: ${sUid}`);
                }
            }

            // 2. Fallback fÃ¼r neue Events (Systemkalender suchen)
            if (!source) {
                const sources = this._registry.list_sources(EDataServer.SOURCE_EXTENSION_CALENDAR);
                source = sources.find((s: any) => {
                    let isWritable = false;
                    try {
                        let extension = s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR);
                        isWritable = !extension.get_readonly();
                    } catch (e) {
                        isWritable = (typeof s.get_readonly === 'function') ? !s.get_readonly() : true;
                    }
                    const name = s.get_display_name().toLowerCase();
                    return isWritable && (name.includes("system") || name.includes("personal") || name.includes("local"));
                });

                if (!source) {
                    source = sources.find((s: any) => {
                        try {
                            return !s.get_extension(EDataServer.SOURCE_EXTENSION_CALENDAR).get_readonly();
                        } catch(e) { return true; }
                    });
                }
            }

            if (!source) {
                global.logError(`${this._uuid}: No source found to save the event.`);
                return;
            }

            // 3. Verbindung zum Kalender-Client herstellen
            ECal.Client.connect(source, ECal.ClientSourceType.EVENTS, 30, null, (_obj, res) => {
                try {
                    const client = ECal.Client.connect_finish(res);

                    // WEICHE: UPDATE (Smart Merge) oder NEUANLAGE
                    if (ev.id && ev.id !== "" && !ev.id.startsWith("ics_")) {
                        
                        // --- FALL A: Bestehenden Termin aktualisieren ---
                        client.get_object(ev.id, null, (_obj2, getRes) => {
                            try {
                                const [success, icalComp] = client.get_object_finish(getRes);
                                if (success && icalComp) {
                                    icalComp.set_summary(ev.summary);
                                    if (ev.description) icalComp.set_description(ev.description);

                                    const tz = ICal.Timezone.get_utc_timezone();
                                    let start: any, end: any;

                                    if (ev.isFullDay) {
                                        start = ICal.Time.new_null_time();
                                        start.set_date(ev.start.getDate(), ev.start.getMonth() + 1, ev.start.getFullYear());
                                        start.set_is_date(true);
                                        end = ICal.Time.new_null_time();
                                        end.set_date(ev.end.getDate(), ev.end.getMonth() + 1, ev.end.getFullYear());
                                        end.set_is_date(true);
                                        if (ev.start.toDateString() === ev.end.toDateString()) {
                                            end.adjust(1, 0, 0, 0);
                                        }
                                    } else {
                                        start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
                                        end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
                                    }

                                    icalComp.set_dtstart(start);
                                    icalComp.set_dtend(end);

                                    client.modify_object(icalComp, ECal.ObjModType.THIS, 0, null, (_c, modRes) => {
                                        try {
                                            client.modify_object_finish(modRes);
                                            global.log(`${this._uuid}: Event updated (Smart Merge).`);
                                        } catch (e) {
                                            global.logError(`${this._uuid}: modify_object_finish failed: ${e}`);
                                        }
                                    });
                                }
                            } catch (e) {
                                global.logError(`${this._uuid}: Error during get_object/Smart Merge: ${e}`);
                            }
                        });

                    } else {
                        // --- FALL B: Neuanlage eines Termins ---
                        const icalComp = ICal.Component.new(ICal.ComponentKind.VEVENT_COMPONENT);
                        icalComp.set_summary(ev.summary);
                        if (ev.description) icalComp.set_description(ev.description);

                        const tz = ICal.Timezone.get_utc_timezone();
                        let start: any, end: any;

                        if (ev.isFullDay) {
                            start = ICal.Time.new_null_time();
                            start.set_date(ev.start.getDate(), ev.start.getMonth() + 1, ev.start.getFullYear());
                            start.set_is_date(true);
                            end = ICal.Time.new_null_time();
                            end.set_date(ev.end.getDate(), ev.end.getMonth() + 1, ev.end.getFullYear());
                            end.set_is_date(true);
                            if (ev.start.toDateString() === ev.end.toDateString()) {
                                end.adjust(1, 0, 0, 0);
                            }
                        } else {
                            start = ICal.Time.new_from_timet_with_zone(Math.floor(ev.start.getTime() / 1000), 0, tz);
                            end = ICal.Time.new_from_timet_with_zone(Math.floor(ev.end.getTime() / 1000), 0, tz);
                        }

                        icalComp.set_dtstart(start);
                        icalComp.set_dtend(end);

                        client.create_object(icalComp, null, (_c, createRes) => {
                            try {
                                const [success, newUid] = client.create_object_finish(createRes);
                                if (success) global.log(`${this._uuid}: New event created. UID: ${newUid}`);
                            } catch (e) {
                                global.logError(`${this._uuid}: create_object_finish failed: ${e}`);
                            }
                        });
                    }
                } catch (e) {
                    global.logError(`${this._uuid}: Calendar client connection failed: ${e}`);
                }
            });
        } catch (e) {
            global.logError(`${this._uuid}: Fatal error in addEvent: ${e}`);
        }
    }
